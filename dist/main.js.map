{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@apestaartje/string/dist/pad.js","webpack:///./node_modules/@apestaartje/string/dist/ucfirst.js","webpack:///./src/json2ts/util/type/getType.ts","webpack:///./src/json2ts/util/equal/isEqual.ts","webpack:///./src/json2ts/util/equal/isEqualObject.ts","webpack:///./src/json2ts/util/equal/isEqualArray.ts","webpack:///./src/json2ts/parser/ast/node/NodeType.ts","webpack:///./src/json2ts/util/array/merge.ts","webpack:///./src/json2ts/util/array/contains.ts","webpack:///./src/json2ts/parser/ast/node/nodeTypeToString.ts","webpack:///./src/json2ts/compiler/compile.ts","webpack:///./src/json2ts/parser/ast/node/isPrimitiveType.ts","webpack:///./src/json2ts/parser/ast/createName.ts","webpack:///./src/json2ts/parser/ast/createAST.ts","webpack:///./src/json2ts/parser/ast/node/getNodeType.ts","webpack:///./src/json2ts/parser/ast/node/createNode.ts","webpack:///./src/json2ts/parser/ast/isAlreadyChild.ts","webpack:///./src/json2ts/json2ts.ts","webpack:///./src/json2ts/parser/parse.ts","webpack:///./src/json2ts/compiler/StringBuffer.ts","webpack:///./src/json2ts/writer/Writer.ts","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PadType","ucfirst","input","length","charAt","toUpperCase","slice","TYPE_RE","getType","raw","toString","matches","exec","Error","isEqual","a","b","aType","getTime","isEqualArray","aKeys","keys","bKeys","every","isEqualObject","clone","arr","sort","aClone","bClone","e","index","NodeType","merge","forEach","element","needle","undefined","find","push","nodeTypeToString","type","String","Number","Boolean","Array","mergeProperties","master","slave","properties","map","isOptional","cloneProperties","existingProperty","searchProperty","prop","findProperty","normalizePropertyTypes","propertyTypes","primitives","nested","propertyType","includes","result","createProperty","node","children","child","isArray","createArrayProperty","createInterface","createObjectProperty","createPrimitiveProperty","nameRegistry","data","getNodeType","createNode","nameProposal","createName","createAST","childNode","newChild","existingChild","json2ts","json","rootName","ast","compile","JSON","parse","StringBuffer","_text","_children","this","str","pre","post","buffer","buffers","toStringTree","join","rootInterface","_rootInterface","append","addChildren","addChild","wrap","newLine","space","tab","trigger","window","document","querySelector","addEventListener","writer","innerHTML","write","className","innerText"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,WAIjBlC,EAAoBA,EAAoBmC,EAAI,G,sECjF9C,IAAIC,GACX,SAAWA,GACPA,EAAQA,EAAc,KAAI,GAAK,OAC/BA,EAAQA,EAAe,MAAI,GAAK,QAFpC,CAGGA,IAAYA,EAAU,KCLlB,SAASC,EAAQC,GACpB,OAAqB,IAAjBA,EAAMC,OACCD,EAEJ,GAAGA,EAAME,OAAO,GAAGC,gBAAgBH,EAAMI,MAAM,KCA1D,MAAMC,EAAkB,sBAGjB,SAASC,EAAQvB,GACpB,MAAMwB,EAAc/B,OAAOkB,UAAUc,SAASvC,KAAKc,GAC7C0B,EAAkCJ,EAAQK,KAAKH,GAErD,GAAgB,OAAZE,GAAuC,IAAnBA,EAAQR,OAC5B,MAAM,IAAIU,MAAM,gCAAgCJ,MAGpD,OAAOE,EAAQ,GCLZ,SAASG,EAAQC,EAAQC,GAC5B,GAAID,IAAMC,EACN,OAAO,EAGX,MAAMC,EAAgBT,EAAQO,GAG9B,OAAIE,IAFkBT,EAAQQ,KAMhB,SAAVC,EACcF,EAAGG,YAAqBF,EAAGE,UAG/B,UAAVD,EAEOE,EAAoBJ,EAAUC,GAG3B,WAAVC,GC5BD,SAAuBF,EAA0BC,GACpD,MAAMI,EAAkB1C,OAAO2C,KAAKN,GAC9BO,EAAkB5C,OAAO2C,KAAKL,GAEpC,OAAII,EAAMjB,SAAWmB,EAAMnB,QAIpBiB,EAAMG,MAAOhC,GACTuB,EAAQC,EAAExB,GAAMyB,EAAEzB,KDoBlBiC,CAAsBT,EAAWC,IE7BhD,SAASS,EAAMC,GAEX,MAAMrD,EAAWqD,EAAIpB,MAAM,GAI3B,OAFAjC,EAAEsD,OAEKtD,EAIJ,SAAS8C,EAAaJ,EAAUC,GAGnC,GAFuBD,EAAEZ,SAEVa,EAAEb,OACb,OAAO,EAIX,MAAMyB,EAAgBH,EAAMV,GAGtBc,EAAgBJ,EAAMT,GAG5B,OAAOY,EAAOL,MAAM,CAACO,EAAQC,IAClBjB,EAAQgB,EAAGD,EAAOE,KC5BjC,IAAYC,ECGL,SAASC,EAAMlB,EAAUC,GAE5B,MAAM3C,EAAW0C,EAAET,MAAM,GASzB,OANAU,EAAEkB,QAASC,ICLR,IAA8BC,GDMA,ICNAA,EDMbD,OCFbE,IDEUhE,ECJNiE,KAAMH,GACNrB,EAAQqB,EAASC,MDIpB/D,EAAEkE,KAAKJ,KAIR9D,EEZJ,SAASmE,EAAiBC,GAC7B,GAAIA,IAAST,EAASU,OAClB,MAAO,SACJ,GAAID,IAAST,EAASW,OACzB,MAAO,SACJ,GAAIF,IAAST,EAASY,QACzB,MAAO,UACJ,GAAIH,IAAST,EAASa,MACzB,MAAO,QACJ,GAAIJ,IAAST,EAAStD,OACzB,MAAO,SAGX,MAAM,IAAImC,MAAM,oBAAoB4B,KCaxC,SAASK,EAAgBC,EAAiCC,GACtD,QAAeX,IAAXU,EACA,OAAOC,EAGX,MAAMC,EApBV,SAAyBF,GACrB,OAAOA,EAAOE,WAAWC,IAAKvD,GACnB,OAAP,wBACOA,GAAQ,CACXwD,YAAY,KAgBaC,CAAgBL,GAmBjD,OAjBAC,EAAMC,WAAWf,QAASvC,IACtB,MAAM0D,EAdd,SAAsBC,EAA4BL,GAC9C,OAAOA,EAAWX,KAAMiB,GACbA,EAAKhF,OAAS+E,EAAe/E,MAYaiF,CAAa7D,EAAUsD,QAE/CZ,IAArBgB,EACAJ,EAAWV,KAAK,OAAD,wBACR5C,GAAQ,CACXwD,YAAY,MAGhBE,EAAiBF,YAAa,EAEzBhC,EAAakC,EAAiBZ,KAAM9C,EAAS8C,QAC9CY,EAAiBZ,KAAOR,EAAMoB,EAAiBZ,KAAM9C,EAAS8C,UAKnE,CACHlE,KAAMwE,EAAOxE,KACb0E,cAIR,SAASQ,EAAuBC,GAC5B,IAAIhE,EACJ,MAAMiE,EAA6B,GAC7BC,EAAyB,GAE/BF,EAAcxB,QAAS2B,IACnB,MAAMpB,EAAejC,EAAQqD,GAEhB,UAATpB,EACAmB,EAAOrB,KAAKsB,GACI,WAATpB,IAA2D,IAAtCkB,EAAWG,SAASD,GAChDF,EAAWpB,KAAKsB,GACA,WAATpB,IACP/C,EAASoD,EAAgBpD,EAAqBmE,MAItD,MAAME,OAAoC1B,IAAX3C,EAAuB,GAAK,CAACA,GAE5D,MAAO,IACAiE,KACAI,KACAH,GAiDX,SAASI,EAAeC,GACpB,GAAIA,EAAKxB,OAAST,EAASa,MACvB,OA/CR,SAA6BoB,GACzB,MAAMxB,EAAuB,GAY7B,OAVAwB,EAAKC,SAAShC,QAASiC,IACnB,MAAMxE,EAAuBqE,EAAeG,GAExCA,EAAM1B,OAAST,EAASa,MACxBJ,EAAKF,KAAK5C,EAAS8C,MAEnBA,EAAKF,QAAQ5C,EAAS8C,QAIvB,CACHlE,KAAM0F,EAAK1F,KACXkE,KAAMgB,EAAuBhB,GAC7B2B,SAAS,EACTjB,YAAY,GA8BLkB,CAAoBJ,GACxB,GAAIA,EAAKxB,OAAST,EAAStD,OAC9B,OA5BR,SAA8BuF,GAC1B,MAAML,EAAsBU,EAAgBL,GAE5C,MAAO,CACH1F,KAAM0F,EAAK1F,KACXkE,KAAM,CACFmB,GAEJQ,SAAS,EACTjB,YAAY,GAmBLoB,CAAqBN,GACzB,ICpIqBhF,EDoIDgF,EAAKxB,QClIlBT,EAASY,SACnB3D,IAAU+C,EAASW,QACnB1D,IAAU+C,EAASU,ODiInB,OAjBR,SAAiCuB,GAC7B,MAAO,CACH1F,KAAM0F,EAAK1F,KACXkE,KAAM,CACFD,EAAiByB,EAAKxB,OAE1B2B,SAAS,EACTjB,YAAY,GAULqB,CAAwBP,GCrIhC,IAAyBhF,EDwI5B,MAAM,IAAI4B,MAAM,yBAAyBoD,EAAKxB,QAGlD,SAAS6B,EAAgBL,GACrB,MAAMhB,EAA2BgB,EAAKC,SAAShB,IAAKiB,GACzCH,EAAeG,IAG1B,MAAO,CACH5F,KAAM0B,EAAQgE,EAAK1F,MACnB0E,eJpJR,SAAYjB,GACR,qBACA,yBACA,uBACA,uBACA,uBALJ,CAAYA,MAAQ,KMMpB,MAAMyC,EAA6B,GCGnC,SAAS,EAAIlG,EAAcmG,GACvB,MAAMjC,ECLH,SAAqBxD,GACxB,MAAMwD,EAAejC,EAAQvB,GAE7B,OAAQwD,GACJ,IAAK,QACD,OAAOT,EAASa,MACpB,IAAK,UACD,OAAQb,EAASY,QACrB,IAAK,SACD,OAAOZ,EAASW,OACpB,IAAK,SACD,OAAOX,EAAStD,OACpB,IAAK,SACD,OAAOsD,EAASU,OACpB,QACI,MAAM,IAAI7B,MAAM,qBAAqB4B,ODVtBkC,CAAYD,GAC7BT,EERH,SAAoB1F,EAAckE,GACrC,MAAO,CACHlE,OACAkE,OACAyB,SAAU,IFIKU,CDKhB,SAAoBC,EAAsBpC,GAC7C,GAAIA,IAAST,EAAStD,OAClB,OAAOmG,EAGX,IAAItG,EAAe0B,EAAQ4E,GAY3B,YAV2BxC,IAAvBoC,EAAalG,KACbkG,EAAalG,GAAQ,GAGrBkG,EAAalG,GAAQ,IACrBA,EAAO,GAAGA,IAAOmE,OAAO+B,EAAalG,OAGzCkG,EAAalG,IAAS,EAEfA,ECtBuBuG,CAAWvG,EAAMkE,GAAOA,GAiBtD,OAfIA,IAAST,EAAStD,OAClBA,OAAO2C,KAAaqD,GACfxC,QAAS3C,IACN0E,EAAKC,SAAS3B,KAAKwC,EAAUxF,EAAoBmF,EAAMnF,OAExDkD,IAAST,EAASa,OAChB6B,EAAMxC,QAASiC,IACpB,MAAMa,EAAkBD,EAAUxG,EAAM4F,GGjB7C,IAAwBc,IHmBCD,OGhBrB3C,IHgBgC4B,EAAKC,SGlB5B5B,KAAM4C,GACXpE,EAAQmE,EAAUC,KHkBjBjB,EAAKC,SAAS3B,KAAKyC,KAKxBf,EAGJ,SAASc,EAAUxG,EAAcmG,GAGpC,ODzBAhG,OAAO2C,KAAKoD,GACPvC,QAAS3C,WAECkF,EAAalF,KCsBrB,EAAIhB,EAAMmG,GI7Bd,SAASS,EAAQC,EAAcC,GAGlC,OPgJG,SAAiBC,GACpB,OAAOhB,EAAgBgB,GOjJhBC,CCHJ,SAAeH,EAAcC,GAGhC,OAAON,EAAUM,EAFQG,KAAKC,MAAML,IDAlBK,CAAML,EAAMC,IEE3B,MAAMK,EAAb,cACY,KAAAC,MAAgB,GACP,KAAAC,UAA4B,GAE7C,eACI,MAAO,IACAC,KAAKD,WAIT,QACHC,KAAKF,OAbc,SAgBhB,UACHE,KAAKF,OAtBiB,KAyBnB,MACHE,KAAKF,OAvBY,KA0Bd,QAAQG,GACXD,KAAKF,MAAQ,GAAGG,IAAMD,KAAKF,QAGxB,OAAOG,GACVD,KAAKF,OAASG,EAGX,KAAKC,EAAaC,GACrBH,KAAKF,MAAQ,GAAGI,IAAMF,KAAKF,QAAQK,IAGhC,QACHH,KAAKF,MAAQ,GAGV,SAASM,GACZJ,KAAKD,UAAUrD,KAAK0D,GAGjB,YAAYC,GACfL,KAAKD,UAAUrD,QAAQ2D,GAGpB,WACH,OAAOL,KAAKF,MAGT,eACH,MAAMzB,EAAqB2B,KAAKD,UAAU1C,IAAKiB,GAAgCA,EAAMgC,gBAErF,MAAO,GAAGN,KAAKF,QAAQzB,EAASkC,KAAK,OCvDtC,MAAM,EAGT,YAAmBC,GACfR,KAAKS,eAAiBD,EAGnB,QACH,OAAOR,KAAKnG,OAAOmG,KAAKS,gBACnBH,eAGD,KAAKzC,EAA+BU,GACxC,MAAM6B,EAAuB,IAAIP,EA8BjC,OA5BAhC,EAAcxB,QAAQ,CAAC2B,EAA4B9B,KAC/C,MAAMU,EAAejC,EAAQqD,GAM7B,GAJI9B,EAAQ,GACRkE,EAAOM,OAAO,KAGL,UAAT9D,EAAkB,CAClB,MAAMmB,EAAuBiC,KAAKpD,KAAqBoB,GAAc,GAErEoC,EAAOM,OAAO,kCAAkC3C,EAAOlD,qBACvDuF,EAAOO,YAAY5C,EAAOM,cACV,WAATzB,GACPwD,EAAOM,OAAO,mCAAiD1C,EAActF,eAC7E0H,EAAOQ,SAASZ,KAAKnG,OAAoBmE,KAEzCoC,EAAOM,OAAO,sCAA8C1C,cAIhEH,EAAcvD,OAAS,GACvB8F,EAAOS,KAAK,IAAK,KAGjBtC,GACA6B,EAAOM,OAAO,MAGXN,EAGH,OAAOvG,GACX,MAAMuG,EAAuB,IAAIP,EA+BjC,OA7BAO,EAAOU,UACPV,EAAOM,OAAO,6DACdN,EAAOW,QACPX,EAAOM,OAAO,sCAAsC7G,EAAOnB,eAC3D0H,EAAOM,OAAO,MAEd7G,EAAOuD,WAAWf,QAASvC,IACvBsG,EAAOU,UACPV,EAAOY,MACPZ,EAAOM,OAAO,qCAAqC5G,EAASpB,eAExDoB,EAASwD,YACT8C,EAAOM,OAAO,KAGlBN,EAAOM,OAAO,KACdN,EAAOW,QAEP,MAAMhD,EAAuBiC,KAAKpD,KAAK9C,EAAS8C,KAAM9C,EAASyE,SAC/D6B,EAAOM,OAAO,sBAAsB3C,EAAOlD,qBAE3CuF,EAAOO,YAAY5C,EAAOM,UAC1B+B,EAAOM,OAAO,OAGlBN,EAAOU,UACPV,EAAOM,OAAO,KACdN,EAAOU,UAEAV,GC7Ef,MAAMa,EAA8BC,OAAOC,SAASC,cAAc,eAC5D,EAAoCF,OAAOC,SAASC,cAAc,aAClE,EAA6BF,OAAOC,SAASC,cAAc,cAC3D,EAA6BF,OAAOC,SAASC,cAAc,cAEjD,OAAZH,GAA8B,OAAV,GAA6B,OAAX,GAA8B,OAAX,GACzDA,EAAQI,iBAAiB,QAAS,KAC9B,IACI,MAAMC,EAAiB,IAAI,EAAOhC,EAAQ,EAAMlG,MAAO,SAGvD,EAAOmI,UAAYD,EAAOE,QAC1B,EAAOC,UAAY,GACnB,EAAOC,UAAY,uBACrB,MAAOzF,GACL,EAAOyF,UAAY,GACnB,EAAOD,UAAY,QACnB,EAAOC,UAAY,sBAA8BzF,EAAGpB","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { repeat } from './repeat';\nexport var PadType;\n(function (PadType) {\n    PadType[PadType[\"Left\"] = 0] = \"Left\";\n    PadType[PadType[\"Right\"] = 1] = \"Right\";\n})(PadType || (PadType = {}));\nexport const pad = (input, char, length, type = PadType.Right) => {\n    let output = input.toString();\n    if (output.length < length) {\n        const count = length - output.length;\n        const affix = repeat(char, count);\n        if (PadType.Left === type) {\n            output = affix + output;\n        }\n        else if (PadType.Right === type) {\n            output += affix;\n        }\n    }\n    return output;\n};\n","export function ucfirst(input) {\n    if (input.length === 0) {\n        return input;\n    }\n    return `${input.charAt(0).toUpperCase()}${input.slice(1)}`;\n}\n","/**\n * Get the type of a variable.\n */\n\nconst TYPE_RE: RegExp = /^\\[object\\s(\\w+)\\]$/;\n\n// tslint:disable-next-line no-any export-name\nexport function getType(value: any): string {\n    const raw: string = Object.prototype.toString.call(value);\n    const matches: RegExpExecArray | null = TYPE_RE.exec(raw);\n\n    if (matches === null || matches.length !== 2) {\n        throw new Error(`Type could not be found for \"${raw}\"`);\n    }\n\n    return matches[1];\n}\n","import { getType } from '../type/getType';\nimport { isEqualArray } from './isEqualArray';\nimport { isEqualObject } from './isEqualObject';\n\n/**\n * Check if any two given variables are structural and by value the same.\n * They don't have to be the same reference.\n */\n\n// tslint:disable-next-line no-any\nexport function isEqual(a: any, b: any): boolean {\n    if (a === b) {\n        return true;\n    }\n\n    const aType: string = getType(a);\n    const bType: string = getType(b);\n\n    if (aType !== bType) {\n        return false;\n    }\n\n    if (aType === 'Date') {\n        return (<Date>a).getTime() === (<Date>b).getTime();\n    }\n\n    if (aType === 'Array') {\n        // tslint:disable-next-line no-any\n        return isEqualArray(<any[]>a, <any[]>b);\n    }\n\n    if (aType === 'Object') {\n        return isEqualObject(<object>a, <object>b);\n    }\n\n    return false;\n}\n","import { isEqual } from './isEqual';\n\n// tslint:disable-next-line no-any\nexport function isEqualObject(a: { [id: string]: any }, b: { [id: string]: any }): boolean {\n    const aKeys: string[] = Object.keys(a);\n    const bKeys: string[] = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n\n    return aKeys.every((key: string): boolean => {\n        return isEqual(a[key], b[key]);\n    });\n}\n","import { isEqual } from './isEqual';\n\n// tslint:disable-next-line no-any\nfunction clone(arr: any[]): any[] {\n    // tslint:disable-next-line no-any\n    const c: any[] = arr.slice(0);\n\n    c.sort();\n\n    return c;\n}\n\n// tslint:disable-next-line no-any\nexport function isEqualArray(a: any[], b: any[]): boolean {\n    const length: number = a.length;\n\n    if (length !== b.length) {\n        return false;\n    }\n\n    // tslint:disable-next-line no-any\n    const aClone: any[] = clone(a);\n\n    // tslint:disable-next-line no-any\n    const bClone: any[] = clone(b);\n\n    // tslint:disable-next-line no-any\n    return aClone.every((e: any, index: number): boolean => {\n        return isEqual(e, bClone[index]);\n    });\n}\n","export enum NodeType {\n    Array,\n    Boolean,\n    Number,\n    Object,\n    String,\n}\n","import { contains } from './contains';\n\n// tslint:disable-next-line no-any export-name\nexport function merge(a: any[], b: any[]): any[] {\n    // tslint:disable-next-line no-any\n    const c: any[] = a.slice(0);\n\n    // tslint:disable-next-line no-any\n    b.forEach((element: any): void => {\n        if (contains(c, element) === false) {\n            c.push(element);\n        }\n    });\n\n    return c;\n}\n","import { isEqual } from '../equal/isEqual';\n\n// tslint:disable-next-line no-any\nexport function contains(arr: any[], needle: any): boolean {\n    // tslint:disable-next-line no-any\n    return arr.find((element: any): boolean => {\n        return isEqual(element, needle);\n    }) !== undefined;\n}\n","import { NodeType } from './NodeType';\n\nexport function nodeTypeToString(type: NodeType): string {\n    if (type === NodeType.String) {\n        return 'string';\n    } else if (type === NodeType.Number) {\n        return 'number';\n    } else if (type === NodeType.Boolean) {\n        return 'boolean';\n    } else if (type === NodeType.Array) {\n        return 'array';\n    } else if (type === NodeType.Object) {\n        return 'object';\n    }\n\n    throw new Error(`Unsupported type ${type}`);\n}\n","import { ucfirst } from '@apestaartje/string';\n\nimport { getType } from '../util/type/getType';\nimport { isEqualArray } from '../util/equal/isEqualArray';\nimport { isPrimitiveType } from '../parser/ast/node/isPrimitiveType';\nimport { merge } from '../util/array/merge';\nimport { Node } from '../parser/ast/node/Node';\nimport { NodeType } from '../parser/ast/node/NodeType';\nimport { nodeTypeToString } from '../parser/ast/node/nodeTypeToString';\nimport { PropertyType } from './PropertyType';\nimport { TSInterface } from './TSInterface';\nimport { TSProperty } from './TSProperty';\n\nfunction cloneProperties(master: TSInterface): TSProperty[] {\n    return master.properties.map((property: TSProperty): TSProperty => {\n        return {\n            ...property,\n            isOptional: true,\n        };\n    });\n}\n\nfunction findProperty(searchProperty: TSProperty, properties: TSProperty[]): TSProperty | undefined {\n    return properties.find((prop: TSProperty): boolean => {\n        return prop.name === searchProperty.name;\n    });\n}\n\nfunction mergeProperties(master: TSInterface | undefined, slave: TSInterface): TSInterface {\n    if (master === undefined) {\n        return slave;\n    }\n\n    const properties: TSProperty[] = cloneProperties(master);\n\n    slave.properties.forEach((property: TSProperty): void => {\n        const existingProperty: TSProperty | undefined = findProperty(property, properties);\n\n        if (existingProperty === undefined) {\n            properties.push({\n                ...property,\n                isOptional: true,\n            });\n        } else {\n            existingProperty.isOptional = false;\n\n            if (!isEqualArray(existingProperty.type, property.type)) {\n                existingProperty.type = merge(existingProperty.type, property.type);\n            }\n        }\n    });\n\n    return {\n        name: master.name,\n        properties,\n    };\n}\n\nfunction normalizePropertyTypes(propertyTypes: PropertyType[]): PropertyType[] {\n    let object: TSInterface | undefined;\n    const primitives: PropertyType[] = [];\n    const nested: PropertyType[] = [];\n\n    propertyTypes.forEach((propertyType: PropertyType): void => {\n        const type: string = getType(propertyType);\n\n        if (type === 'Array') {\n            nested.push(propertyType);\n        } else if (type === 'String' && primitives.includes(propertyType) === false) {\n            primitives.push(propertyType);\n        } else if (type === 'Object') {\n            object = mergeProperties(object, <TSInterface>propertyType);\n        }\n    });\n\n    const result: PropertyType[] = object === undefined ? [] : [object];\n\n    return [\n        ...primitives,\n        ...result,\n        ...nested,\n    ];\n}\n\nfunction createArrayProperty(node: Node): TSProperty {\n    const type: PropertyType[] = [];\n\n    node.children.forEach((child: Node): void => {\n        const property: TSProperty = createProperty(child);\n\n        if (child.type === NodeType.Array) {\n            type.push(property.type);\n        } else {\n            type.push(...property.type);\n        }\n    });\n\n    return {\n        name: node.name,\n        type: normalizePropertyTypes(type),\n        isArray: true,\n        isOptional: false,\n    };\n}\n\nfunction createObjectProperty(node: Node): TSProperty {\n    const nested: TSInterface = createInterface(node);\n\n    return {\n        name: node.name,\n        type: [\n            nested,\n        ],\n        isArray: false,\n        isOptional: false,\n    };\n}\n\nfunction createPrimitiveProperty(node: Node): TSProperty {\n    return {\n        name: node.name,\n        type: [\n            nodeTypeToString(node.type),\n        ],\n        isArray: false,\n        isOptional: false,\n    };\n}\n\nfunction createProperty(node: Node): TSProperty {\n    if (node.type === NodeType.Array) {\n        return createArrayProperty(node);\n    } else if (node.type === NodeType.Object) {\n        return createObjectProperty(node);\n    } else if (isPrimitiveType(node.type)) {\n        return createPrimitiveProperty(node);\n    }\n\n    throw new Error(`Unsupported node type ${node.type}`);\n}\n\nfunction createInterface(node: Node): TSInterface {\n    const properties: TSProperty[] = node.children.map((child: Node): TSProperty => {\n        return createProperty(child);\n    });\n\n    return {\n        name: ucfirst(node.name),\n        properties,\n    };\n}\n\nexport function compile(ast: Node): TSInterface {\n    return createInterface(ast);\n}\n","import { NodeType } from './NodeType';\n\nexport function isPrimitiveType(value: NodeType): boolean {\n    return (\n        value === NodeType.Boolean ||\n        value === NodeType.Number ||\n        value === NodeType.String\n    );\n}\n","import { ucfirst } from '@apestaartje/string';\n\nimport { NodeType } from './node/NodeType';\n\ntype NameRegistry = {[key: string]: number};\n\nconst nameRegistry: NameRegistry = {};\n\nexport function flush(): void {\n    Object.keys(nameRegistry)\n        .forEach((key: string): void => {\n            // tslint:disable-next-line no-dynamic-delete\n            delete nameRegistry[key];\n        });\n}\n\nexport function createName(nameProposal: string, type: NodeType): string {\n    if (type !== NodeType.Object) {\n        return nameProposal;\n    }\n\n    let name: string = ucfirst(nameProposal);\n\n    if (nameRegistry[name] === undefined) {\n        nameRegistry[name] = 0;\n    }\n\n    if (nameRegistry[name] > 0) {\n        name = `${name}${String(nameRegistry[name])}`;\n    }\n\n    nameRegistry[name] += 1;\n\n    return name;\n}\n","import { Json } from '@apestaartje/types';\n\nimport { createName, flush } from './createName';\nimport { createNode } from './node/createNode';\nimport { getNodeType } from './node/getNodeType';\nimport { isAlreadyChild } from './isAlreadyChild';\nimport { Node } from './node/Node';\nimport { NodeType } from './node/NodeType';\n\nfunction ast(name: string, data: Json): Node {\n    const type: NodeType = getNodeType(data);\n    const node: Node = createNode(createName(name, type), type);\n\n    if (type === NodeType.Object) {\n        Object.keys(<object>data)\n            .forEach((key: string): void => {\n                node.children.push(createAST(key, <Json>(<object>data)[key]));\n            });\n    } else if (type === NodeType.Array) {\n        (<Json[]>data).forEach((child: Json): void => {\n            const childNode: Node = createAST(name, child);\n\n            if (!isAlreadyChild(childNode, node.children)) {\n                node.children.push(childNode);\n            }\n        });\n    }\n\n    return node;\n}\n\nexport function createAST(name: string, data: Json): Node {\n    flush();\n\n    return ast(name, data);\n}\n","import { Json } from '@apestaartje/types';\n\nimport { getType } from '../../../util/type/getType';\nimport { NodeType } from './NodeType';\n\nexport function getNodeType(value: Json): NodeType {\n    const type: string = getType(value);\n\n    switch (type) {\n        case 'Array':\n            return NodeType.Array;\n        case 'Boolean':\n            return  NodeType.Boolean;\n        case 'Number':\n            return NodeType.Number;\n        case 'Object':\n            return NodeType.Object;\n        case 'String':\n            return NodeType.String;\n        default:\n            throw new Error(`Unsupported type \"${type}\"`);\n    }\n}\n","import { Node } from './Node';\nimport { NodeType } from './NodeType';\n\nexport function createNode(name: string, type: NodeType): Node {\n    return {\n        name,\n        type,\n        children: [],\n    };\n}\n","import { isEqual } from '../../util/equal/isEqual';\nimport { Node } from './node/Node';\n\nexport function isAlreadyChild(newChild: Node, children: Node[]): boolean {\n    return children.find((existingChild: Node): boolean => {\n        return isEqual(newChild, existingChild);\n    }) !== undefined;\n}\n","import { compile } from './compiler/compile';\nimport { Node } from './parser/ast/node/Node';\nimport { parse } from './parser/parse';\nimport { TSInterface } from './compiler/TSInterface';\n\nexport function json2ts(json: string, rootName: string): TSInterface {\n    const ast: Node = parse(json, rootName);\n\n    return compile(ast);\n}\n","import { Json } from '@apestaartje/types';\n\nimport { createAST } from './ast/createAST';\nimport { Node } from './ast/node/Node';\n\nexport function parse(json: string, rootName: string): Node {\n    const data: Json = <Json>JSON.parse(json);\n\n    return createAST(rootName, data);\n}\n","// tslint:disable-next-line quotemark\nconst NEW_LINE_CHAR: string = \"\\n\";\n\n// tslint:disable-next-line quotemark\nconst TAB_CHAR: string = \"\\t\";\n\nconst SPACE_CHAR: string = '&nbsp;';\n\nexport class StringBuffer {\n    private _text: string = '';\n    private readonly _children: StringBuffer[] = [];\n\n    get children(): StringBuffer[] {\n        return [\n            ...this._children,\n        ];\n    }\n\n    public space(): void {\n        this._text += SPACE_CHAR;\n    }\n\n    public newLine(): void {\n        this._text += NEW_LINE_CHAR;\n    }\n\n    public tab(): void {\n        this._text += TAB_CHAR;\n    }\n\n    public prepend(str: string): void {\n        this._text = `${str}${this._text}`;\n    }\n\n    public append(str: string): void {\n        this._text += str;\n    }\n\n    public wrap(pre: string, post: string): void {\n        this._text = `${pre}${this._text}${post}`;\n    }\n\n    public flush(): void {\n        this._text = '';\n    }\n\n    public addChild(buffer: StringBuffer): void {\n        this._children.push(buffer);\n    }\n\n    public addChildren(buffers: StringBuffer[]): void {\n        this._children.push(...buffers);\n    }\n\n    public toString(): string {\n        return this._text;\n    }\n\n    public toStringTree(): string {\n        const children: string[] = this._children.map((child: StringBuffer): string => child.toStringTree());\n\n        return `${this._text}${children.join('')}`;\n    }\n}\n","import { getType } from '../util/type/getType';\nimport { PropertyType } from '../compiler/PropertyType';\nimport { StringBuffer } from '../compiler/StringBuffer';\nimport { TSInterface } from '../compiler/TSInterface';\nimport { TSProperty } from '../compiler/TSProperty';\n\nexport class Writer {\n    private readonly _rootInterface: TSInterface;\n\n    public constructor(rootInterface: TSInterface) {\n        this._rootInterface = rootInterface;\n    }\n\n    public write(): string {\n        return this.object(this._rootInterface)\n            .toStringTree();\n    }\n\n    private type(propertyTypes: PropertyType[], isArray: boolean): StringBuffer {\n        const buffer: StringBuffer = new StringBuffer();\n\n        propertyTypes.forEach((propertyType: PropertyType, index: number): void => {\n            const type: string = getType(propertyType);\n\n            if (index > 0) {\n                buffer.append('|');\n            }\n\n            if (type === 'Array') {\n                const nested: StringBuffer = this.type(<PropertyType[]>propertyType, true);\n\n                buffer.append(`<span class=\"type type--array\">${nested.toString()}</span>`);\n                buffer.addChildren(nested.children);\n            } else if (type === 'Object') {\n                buffer.append(`<span class=\"type type--object\">${(<TSInterface>propertyType).name}</span>`);\n                buffer.addChild(this.object(<TSInterface>propertyType));\n            } else {\n                buffer.append(`<span class=\"type type--primitive\">${<string>propertyType}</span>`);\n            }\n        });\n\n        if (propertyTypes.length > 1) {\n            buffer.wrap('(', ')');\n        }\n\n        if (isArray) {\n            buffer.append('[]');\n        }\n\n        return buffer;\n    }\n\n    private object(object: TSInterface): StringBuffer {\n        const buffer: StringBuffer = new StringBuffer();\n\n        buffer.newLine();\n        buffer.append('<span class=\"keyword keyword--interface\">interface</span>');\n        buffer.space();\n        buffer.append(`<span class=\"name name--interface\">${object.name}</span>`);\n        buffer.append(' {');\n\n        object.properties.forEach((property: TSProperty): void => {\n            buffer.newLine();\n            buffer.tab();\n            buffer.append(`<span class=\"name name--property\">${property.name}</span>`);\n\n            if (property.isOptional) {\n                buffer.append('?');\n            }\n\n            buffer.append(':');\n            buffer.space();\n\n            const nested: StringBuffer = this.type(property.type, property.isArray);\n            buffer.append(`<span class=\"type\">${nested.toString()}</span>`);\n\n            buffer.addChildren(nested.children);\n            buffer.append(';');\n        });\n\n        buffer.newLine();\n        buffer.append('}');\n        buffer.newLine();\n\n        return buffer;\n    }\n}\n","import { json2ts } from './json2ts/json2ts';\nimport { Writer } from './json2ts/writer/Writer';\n\n/**\n * This is just an example on how to use the JSON to Interface package.\n */\n\nconst trigger: HTMLElement | null = window.document.querySelector('.js-trigger');\nconst input: HTMLTextAreaElement | null = window.document.querySelector('.js-input');\nconst output: HTMLElement | null = window.document.querySelector('.js-output');\nconst status: HTMLElement | null = window.document.querySelector('.js-status');\n\nif (trigger !== null && input !== null && output !== null && status !== null) {\n    trigger.addEventListener('click', (): void => {\n        try {\n            const writer: Writer = new Writer(json2ts(input.value, 'root'));\n\n            // tslint:disable-next-line no-inner-html\n            output.innerHTML = writer.write();\n            status.className = '';\n            status.innerText = '✅ Compile successful';\n        } catch (e) {\n            output.innerText = '';\n            status.className = 'error';\n            status.innerText = `❌ Error compiling: ${(<Error>e).toString()}`;\n        }\n    });\n}\n"],"sourceRoot":""}